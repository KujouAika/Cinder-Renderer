# Cinder Engine

**NOTE**: This Document is generated by Gemini 3 Pro.

![Vulkan](https://img.shields.io/badge/Vulkan-1.3-%23AC162C?style=flat&logo=vulkan)
![C++](https://img.shields.io/badge/C%2B%2B-20-blue?style=flat&logo=c%2B%2B)
![Platform](https://img.shields.io/badge/Platform-Windows-lightgrey?style=flat&logo=windows)
![License](https://img.shields.io/badge/License-MIT-green)

**Cinder** is a high-performance, next-generation rendering engine built from scratch using **C++20** and **Vulkan 1.3**.

Designed as a rigorous research testbed, Cinder aims to implement and **benchmark** modern AAA rendering techniques found in Unreal Engine 5 (Nanite, Lumen) against a lightweight, hand-crafted architecture. The engine prioritizes explicit resource management, hardware-oriented optimizations (Async Compute, Bindless), and extensive **A/B testing capabilities**.

---

## ✨ Key Features

### 🏗️ Core Engineering & Infrastructure
* **Zero-Overhead RAII**: Custom template-based resource wrappers (`TVulkanHandle<T>`) ensuring leak-free lifecycle management without runtime cost.
* **Robust Error Handling**: Unreal-style strippable assertion macros (`check`, `ensure`) and a validation layer "watchdog" for fail-fast debugging.
* **Modern C++20**: Extensive use of `std::span`, `concepts`, and module-based architecture.
* **Multi-threaded Architecture**: Job-system based parallel Command Buffer recording to minimize CPU bottlenecks.

### 🚀 GPU-Driven Pipeline
* **Multi-Draw Indirect (MDI)**: Rendering millions of instances via GPU-generated commands.
* **Bindless Materials**: `Descriptor Indexing` architecture allowing global texture access via runtime IDs.
* **Advanced Culling**: Compute Shader-based *Frustum Culling* and *Hierarchical Z-Buffer (Hi-Z) Occlusion*.

### 🔺 Virtual Geometry (Nanite-like)
* **Visibility Buffer**: Decoupled geometry/material pass eliminating overdraw.
* **Hybrid Rasterization**: Seamless switching between Hardware Mesh Shaders and a hand-written **Compute Software Rasterizer** (using 64-bit Atomics) for micro-polygons.

### 🔦 Hybrid Global Illumination (Lumen-like)
* **Hybrid Rendering**: Combining *Cascaded Shadow Maps (CSM)* for near-field sharpness with *SDF Ray Tracing* for far-field softness.
* **Lumen-Lite**: Real-time GI via *Signed Distance Fields (SDF)*, *Global Distance Fields (Clipmap)*, and *Radiance Caching*.
* **Anime-Style Denoising**: Specialized "Temporal-First" denoising pipeline separating GI and Reflection signals.

### ⚡ RTX 40 Series & Next-Gen
* **DLSS 4**: Integration of NVIDIA Streamline for Super Resolution and **Frame Generation**.
* **RTX Optimization**: Utilizing **SER** (Shader Execution Reordering) and **OMM** (Opacity Micromaps) for vegetation rendering.
* **HDR Output**: 10-bit Swapchain support with ACES Tone Mapping.

---

## 🗺️ Roadmap

### Phase I: Foundation & RHI
*Establishing a robust backend comparable to UE5's RHI.*
- [x] **Project Setup**: CMake, VS2022, SDL2 environment.
- [x] **Vulkan Init**: Robust Instance creation with Validation Layer hooks.
- [x] **Device Strategy**: Physical device ranking & Logical device with **Multi-Queue** (Async Compute) support.
- [ ] **Memory Management**: Integration of **VMA** (Vulkan Memory Allocator).
- [x] **Infrastructure**: Implementation of RAII and `check/verify` macros.
- [ ] **Presentation**: Swapchain creation with robust Resize/Minimize handling.
- [ ] **RHI Abstraction**: Encapsulating commands into `RHICommandList`.

### Phase II: Architecture & Multithreading
*Eliminating CPU bottlenecks.*
- [ ] **GPU Data**: Pull-Mode Vertex Fetching (SSBO).
- [ ] **Job System**: C++ Task Graph implementation.
- [ ] **Multithreading**: Parallel Command Buffer recording.
- [ ] **Culling**: Compute Shader Frustum Culling.
- [ ] **Occlusion**: Hi-Z Buffer generation & Two-Pass Occlusion Culling.
- [ ] **MDI**: Multi-Draw Indirect integration (Toggle: MDI vs Loop).
- [ ] **Async Compute**: Dedicated queue for culling tasks.

### Phase III: Material & Virtualization
*Breaking resource limits.*
- [ ] **Reflection**: Automatic Layout generation via `SPIRV-Reflect`.
- [ ] **PSO Cache**: Pipeline State Object caching system.
- [ ] **Bindless**: Global Texture Array (Descriptor Indexing).
- [ ] **Virtual Texture**: Sparse Image & Page Table implementation.
- [ ] **Virtual Shadow Maps (VSM)**: Physical page management & caching strategy.

### Phase IV: Next-Gen Geometry
*Replicating Nanite's core.*
- [ ] **Meshlets**: Generation via `meshoptimizer`.
- [ ] **Mesh Shaders**: Hardware pipeline implementation.
- [ ] **VisBuffer**: ID Buffer rendering & Material reconstruction.
- [ ] **Software Rasterizer**: Compute Shader rasterizer (64-bit Atomics).
- [ ] **Hybrid Pipeline**: Dynamic switching between HW/SW Rasterization.
- [ ] **Streaming**: Error-metric based LOD selection (DAG).

### Phase V: Global Illumination
*Hybrid Lumen-Lite & RTX features.*
- [ ] **SDF**: Mesh Distance Field & Global Clipmap generation.
- [ ] **SWRT**: Software Ray Tracing (Sphere Tracing).
- [ ] **Radiance Cache**: Probe hierarchy update.
- [ ] **Hybrid Shadows**: Blending CSM + SDF Shadows.
- [ ] **RTX 40**: Integration of **SER** and **OMM**.
- [ ] **Denoising**: Separate Temporal/Spatial filter chain.

### Phase VI: Engineering & Mobile
*Final polish and platform verification.*
- [ ] **Runtime Config**: Full ImGui-based feature toggling system.
- [ ] **HDR**: 10-bit Output & Tone Mapping.
- [ ] **DLSS 4**: Streamline SDK integration (SR + FG).
- [ ] **Optimization**: TaskGraph load balancing & LRU streaming.
- [ ] **Mobile Verification**: iOS Build & Tile Memory Bandwidth analysis (TBDR).

---

## 🚀 Getting Started

### Prerequisites
* **Visual Studio 2022** (C++ Desktop Development)
* **Vulkan SDK** (Vulkan 1.3+ with SDL2, GLM)
* **CMake** (3.25+)
* **GPU**: RTX 20 series+ (RTX 40 series recommended for SER/OMM/DLSS 3+)
