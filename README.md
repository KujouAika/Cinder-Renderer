# Cinder-Renderer


![Vulkan](https://img.shields.io/badge/Vulkan-1.3-%23AC162C?style=flat&logo=vulkan)
![C++](https://img.shields.io/badge/C%2B%2B-20-blue?style=flat&logo=c%2B%2B)
![Platform](https://img.shields.io/badge/Platform-Windows-lightgrey?style=flat&logo=windows)
![License](https://img.shields.io/badge/License-MIT-green)

**Note**: This Document is generated by Gemini 3 Pro.

**Cinder-Renderer** is a high-performance, next-generation rendering engine.

This project serves as a research testbed for implementing modern AAA rendering techniques found in engines like Unreal Engine 5, including **GPU-Driven Rendering**, **Virtual Geometry (Nanite-like)**, and **Dynamic Global Illumination (Lumen-like)**. The architecture prioritizes loose coupling, explicit resource management, and hardware-oriented optimizations (e.g., Async Compute, Bindless Resources).

## 🛠️ Technology Stack

* **Core API:** Vulkan 1.3 (SDL2, GLM, Dynamic Rendering, Synchronization 2)
* **Language:** C++ 20 (Smart Pointers, Concepts, Modules structure)
* **Build System:** CMake(3.25+)
* **Memory Management:** Vulkan Memory Allocator (VMA)


## ✨ Key Features

### 🏗️ Core Architecture
* **Modern C++20 & Vulkan 1.3**: Built on the latest standards utilizing *Dynamic Rendering* and *Synchronization 2* for maximum driver efficiency.
* **Asynchronous Compute**: Advanced queue ownership transfer and dedicated compute queue utilization for overlapping tasks (e.g., Culling, GI updates).
* **Multi-threaded RHI**: Job-system based parallel Command Buffer recording to minimize CPU bottlenecks.

### 🎨 Bindless Material Pipeline
* **Descriptor Indexing**: Full bindless architecture allowing shaders to access global texture arrays via runtime indices, eliminating descriptor set binding overhead.
* **Data-Driven**: Automated DescriptorSet layout generation using *SPIRV-Reflect*.

### 🚀 GPU-Driven Rendering
* **Multi-Draw Indirect (MDI)**: Rendering millions of instances with a single CPU draw call via GPU-generated commands.
* **Precise Culling**: Compute Shader-based *Frustum Culling* and *Hierarchical Z-Buffer (Hi-Z) Occlusion Culling*.

### 🔺 Virtual Geometry (Nanite-like)
* **Meshlet Pipeline**: Cluster-based geometry processing supporting both Hardware *Mesh Shaders* and Software fallbacks.
* **Visibility Buffer**: Decoupled geometry and material evaluation pass to eliminate pixel shading overdraw.
* **Compute Software Rasterizer**: Hand-written rasterization logic using 64-bit Atomics for efficient micro-polygon rendering.

### 🔦 Hybrid Global Illumination (Lumen-like)
* **Software Ray Tracing (SWRT)**: Real-time Global Illumination and Reflections based on *Signed Distance Fields (SDF)* and *Global Distance Fields (Clipmap)*.
* **Radiance Caching**: Surface cache and probe hierarchy for stable indirect lighting.
* **Hybrid Shadows**: Seamless blending between *Cascaded Shadow Maps (CSM)* for near-field detail and *Ray Traced Shadows* for far-field softness.

### ⚡ RTX 40 Series Optimization
* **Shader Execution Reordering (SER)**: optimizing ray tracing divergence in complex scenes (e.g., foliage).
* **Opacity Micromaps (OMM)**: Accelerating alpha-tested geometry intersection for high-performance vegetation rendering.


## 🗺️ Roadmap & Progress

This project follows a strict 6-Phase implementation plan aimed at achieving Senior Graphics Programmer proficiency.

### Phase I: Foundation & RHI (Current Focus)
Establishing a robust rendering backend and RHI abstraction layer.
- [x] **Project Setup**: CMake environment & Visual Studio integration.
- [x] **Vulkan Initialization**: Instance creation & Validation Layers hooks.
- [x] **Device Selection**: Physical device ranking & Logical device creation with Multi-Queue support.
- [ ] **Memory Management**: Integration of **VMA** (Vulkan Memory Allocator).
- [ ] **Presentation**: Swapchain creation & Robust resize handling.
- [ ] **Render Loop**: Basic RenderPass & Framebuffer setup (Hello Triangle).
- [ ] **RHI Abstraction**: Encapsulating commands into `RHICommandList`.

### Phase II: High-Performance Architecture
Eliminating CPU bottlenecks via Multi-threading and GPU-Driven pipelines.
- [ ] **GPU Data**: Pull-Mode Vertex Fetching (SSBO replacement for VBO).
- [ ] **Job System**: Implementation of a C++ Task/Job system.
- [ ] **Multithreading**: Parallel Command Buffer recording.
- [ ] **Culling System**: Compute Shader Frustum Culling.
- [ ] **Hi-Z**: Hierarchical Z-Buffer construction for occlusion culling.
- [ ] **MDI**: **Multi-Draw Indirect** pipeline integration.
- [ ] **Async Compute**: Dedicated queue for culling and resource upload.

### Phase III: Material Pipeline & Virtualization
Breaking resource limits with Bindless architecture.
- [ ] **Shader Reflection**: Automatic DescriptorSet layout generation via SPIRV-Reflect.
- [ ] **PSO Management**: Pipeline State Object caching system.
- [ ] **Bindless**: **Descriptor Indexing** (Global Texture Arrays).
- [ ] **Virtual Texture**: Sparse Image & Page Table implementation.
- [ ] **Virtual Shadow Maps (VSM)**: Physical page management & caching strategy.

### Phase IV: Next-Gen Geometry (Nanite-like)
Implementing a Cluster-based geometry pipeline with software rasterization.
- [ ] **Mesh Processing**: Meshlet generation using `meshoptimizer`.
- [ ] **Mesh Shaders**: Hardware `VK_EXT_mesh_shader` pipeline.
- [ ] **Visibility Buffer**: ID Buffer rendering & Material reconstruction pass.
- [ ] **Software Rasterizer**: Compute Shader rasterization for micro-polygons (64-bit Atomics).
- [ ] **Hybrid Pipeline**: Seamless switching between HW/SW rasterization.

### Phase V: Global Illumination (Lumen-like)
Real-time dynamic GI and Ray Tracing.
- [ ] **SDF**: Mesh Distance Field generation & Global Distance Field (Clipmap).
- [ ] **Software Ray Tracing**: Sphere Tracing implementation in Compute Shader.
- [ ] **Radiance Cache**: Probe hierarchy update & interpolation.
- [ ] **Hybrid Shadows**: Combining CSM with SDF/Ray-Traced shadows.
- [ ] **RTX Optimization**: **SER** (Shader Execution Reordering) & **OMM** (Opacity Micromap).

### Phase VI: Engineering & Optimization
Final polish and platform-specific optimizations.
- [ ] **Profiling**: Deep analysis using RenderDoc & Nsight.
- [ ] **Optimization**: TaskGraph load balancing & LRU streaming.
- [ ] **Mobile**: iOS Build verification & Bandwidth analysis (TBDR).

---
