# Vulkan Core Renderer


![Vulkan](https://img.shields.io/badge/Vulkan-1.3-%23AC162C?style=flat&logo=vulkan)
![C++](https://img.shields.io/badge/C%2B%2B-20-blue?style=flat&logo=c%2B%2B)
![Platform](https://img.shields.io/badge/Platform-Windows-lightgrey?style=flat&logo=windows)
![License](https://img.shields.io/badge/License-MIT-green)

**Note**: This Document is generated by Gemini 3 Pro.

**Vulkan Core Renderer** is a high-performance, next-generation rendering engine built from scratch using **C++20** and **Vulkan 1.3**.

This project serves as a research testbed for implementing modern AAA rendering techniques found in engines like Unreal Engine 5, including **GPU-Driven Rendering**, **Virtual Geometry (Nanite-like)**, and **Dynamic Global Illumination (Lumen-like)**. The architecture prioritizes loose coupling, explicit resource management, and hardware-oriented optimizations (e.g., Async Compute, Bindless Resources).

## 🛠️ Technology Stack

* **Core API:** Vulkan 1.3 (Dynamic Rendering, Synchronization 2)
* **Language:** C++ 20 (Smart Pointers, Concepts, Modules structure)
* **Build System:** CMake
* **Window System:** SDL2
* **Memory Management:** Vulkan Memory Allocator (VMA)
* **Math:** GLM
* **Shader Reflection:** SPIRV-Reflect

## Prerequisites
* **Visual Studio 2022** (C++ Desktop Development workload)
* **Vulkan SDK** (Latest version recommended, must include SDL2)
* **CMake** (3.25+)


## 🗺️ Roadmap & Progress

This project follows a strict 6-Phase implementation plan aimed at achieving Senior Graphics Programmer proficiency.

### Phase I: Foundation & RHI (Current Focus)
Establishing a robust rendering backend and RHI abstraction layer.
- [x] **Project Setup**: CMake environment & Visual Studio integration.
- [x] **Vulkan Initialization**: Instance creation & Validation Layers hooks.
- [x] **Device Selection**: Physical device ranking & Logical device creation with Multi-Queue support.
- [ ] **Memory Management**: Integration of **VMA** (Vulkan Memory Allocator).
- [ ] **Presentation**: Swapchain creation & Robust resize handling.
- [ ] **Render Loop**: Basic RenderPass & Framebuffer setup (Hello Triangle).
- [ ] **RHI Abstraction**: Encapsulating commands into `RHICommandList`.

### Phase II: High-Performance Architecture
Eliminating CPU bottlenecks via Multi-threading and GPU-Driven pipelines.
- [ ] **GPU Data**: Pull-Mode Vertex Fetching (SSBO replacement for VBO).
- [ ] **Job System**: Implementation of a C++ Task/Job system.
- [ ] **Multithreading**: Parallel Command Buffer recording.
- [ ] **Culling System**: Compute Shader Frustum Culling.
- [ ] **Hi-Z**: Hierarchical Z-Buffer construction for occlusion culling.
- [ ] **MDI**: **Multi-Draw Indirect** pipeline integration.
- [ ] **Async Compute**: Dedicated queue for culling and resource upload.

### Phase III: Material Pipeline & Virtualization
Breaking resource limits with Bindless architecture.
- [ ] **Shader Reflection**: Automatic DescriptorSet layout generation via SPIRV-Reflect.
- [ ] **PSO Management**: Pipeline State Object caching system.
- [ ] **Bindless**: **Descriptor Indexing** (Global Texture Arrays).
- [ ] **Virtual Texture**: Sparse Image & Page Table implementation.
- [ ] **Virtual Shadow Maps (VSM)**: Physical page management & caching strategy.

### Phase IV: Next-Gen Geometry (Nanite-like)
Implementing a Cluster-based geometry pipeline with software rasterization.
- [ ] **Mesh Processing**: Meshlet generation using `meshoptimizer`.
- [ ] **Mesh Shaders**: Hardware `VK_EXT_mesh_shader` pipeline.
- [ ] **Visibility Buffer**: ID Buffer rendering & Material reconstruction pass.
- [ ] **Software Rasterizer**: Compute Shader rasterization for micro-polygons (64-bit Atomics).
- [ ] **Hybrid Pipeline**: Seamless switching between HW/SW rasterization.

### Phase V: Global Illumination (Lumen-like)
Real-time dynamic GI and Ray Tracing.
- [ ] **SDF**: Mesh Distance Field generation & Global Distance Field (Clipmap).
- [ ] **Software Ray Tracing**: Sphere Tracing implementation in Compute Shader.
- [ ] **Radiance Cache**: Probe hierarchy update & interpolation.
- [ ] **Hybrid Shadows**: Combining CSM with SDF/Ray-Traced shadows.
- [ ] **RTX Optimization**: **SER** (Shader Execution Reordering) & **OMM** (Opacity Micromap).

### Phase VI: Engineering & Optimization
Final polish and platform-specific optimizations.
- [ ] **Profiling**: Deep analysis using RenderDoc & Nsight.
- [ ] **Optimization**: TaskGraph load balancing & LRU streaming.
- [ ] **Mobile**: iOS Build verification & Bandwidth analysis (TBDR).

---
